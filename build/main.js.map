{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\nimport axios from \"axios\";\n\nclass LiquidCheck extends utils.Adapter {\n\tprivate interval: any;\n\n\tprivate async processData(data: any, path: string = \"\"): Promise<void> {\n    \tfor (const key of Object.keys(data)) {\n        \tconst value = data[key];\n        \tconst stateId = path ? `${path}.${key}` : key;\n\t\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\t\tawait this.processData(value, stateId); // Rekursiv tiefer gehen\n\t\t\t} else {\n\t\t\t\tthis.log.info(`Processing key: ${stateId} with value: ${value}`);\n\t\t\t\tlet type: \"string\" | \"number\" | \"boolean\";\n\t\t\t\tswitch (typeof value) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttype = \"string\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\ttype = \"number\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttype = \"string\"; // Fallback f\u00FCr nicht unterst\u00FCtzte Typen\n\t\t\t\t}\n\n\t\t\t\tawait this.setObjectNotExistsAsync(stateId, {\n\t\t\t\t\ttype: \"state\",\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: stateId,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\trole: \"value\",\n\t\t\t\t\t\tread: true,\n\t\t\t\t\t\twrite: false,\n\t\t\t\t\t},\n\t\t\t\t\tnative: {},\n\t\t\t\t});\n\n\t\t\t\tawait this.setStateAsync(stateId, { val: value, ack: true });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async fetchData(): Promise<void> {\n\t\ttry {\n\t\t\tconst response = await axios.get(this.config.option2, { timeout: 10000 });\n\t\t\tconst data = response.data; // JSON\n\t\t\tthis.log.info(\"Daten empfangen: \" + JSON.stringify(data));\n\n\t\t\tawait this.processData(data.payload);\n\n\t\t} catch (err: any) {\n\t\t\tthis.log.error(\"Fehler beim Laden der Daten: \" + err.message);\n\t\t}\n\t}\n\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: \"liquid-check\",\n\t\t});\n\t\tthis.on(\"ready\", this.onReady.bind(this));\n\t\tthis.on(\"stateChange\", this.onStateChange.bind(this));\n\t\t// this.on(\"objectChange\", this.onObjectChange.bind(this));\n\t\t// this.on(\"message\", this.onMessage.bind(this));\n\t\tthis.on(\"unload\", this.onUnload.bind(this));\n\t}\n\n\t/**\n\t * Is called when databases are connected and adapter received configuration.\n\t */\n\tprivate async onReady(): Promise<void> {\n\t\t// Initialize your adapter here\n\n\t\t// The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n\t\t// this.config:\n\t\tthis.log.info(\"Poll Intervall: \" + this.config.checkInterval);\n\t\tthis.log.info(\"Poll Url option2: \" + this.config.option2);\n\n\t\tawait this.fetchData();\n\n    \t// Dann alle 60 Sekunden erneut\n\t\tconst intervalMs = (this.config.checkInterval || 15) * 1000;\n\t\tthis.interval = this.setInterval(() => this.fetchData(), intervalMs);\n\t}\n\n\t/**\n\t * Is called when adapter shuts down - callback has to be called under any circumstances!\n\t */\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\t// Here you must clear all timeouts or intervals that may still be active\n\t\t\t// clearTimeout(timeout1);\n\t\t\t// clearTimeout(timeout2);\n\t\t\t// ...\n\t\t\t// clearInterval(interval1);\n\t\t\tif (this.interval) {\n\t\t\t\tclearInterval(this.interval);\n\t\t\t}\n\t\t\tcallback();\n\t\t} catch (e) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t// If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n\t// You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n\t// /**\n\t//  * Is called if a subscribed object changes\n\t//  */\n\t// private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n\t// \tif (obj) {\n\t// \t\t// The object was changed\n\t// \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n\t// \t} else {\n\t// \t\t// The object was deleted\n\t// \t\tthis.log.info(`object ${id} deleted`);\n\t// \t}\n\t// }\n\n\t/**\n\t * Is called if a subscribed state changes\n\t */\n\tprivate onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n\t\tif (state) {\n\t\t\t// The state was changed\n\t\t\tthis.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\t\t} else {\n\t\t\t// The state was deleted\n\t\t\tthis.log.info(`state ${id} deleted`);\n\t\t}\n\t}\n\n\t// If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n\t// /**\n\t//  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n\t//  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n\t//  */\n\t// private onMessage(obj: ioBroker.Message): void {\n\t// \tif (typeof obj === \"object\" && obj.message) {\n\t// \t\tif (obj.command === \"send\") {\n\t// \t\t\t// e.g. send email or pushover or whatever\n\t// \t\t\tthis.log.info(\"send command\");\n\n\t// \t\t\t// Send response in callback if required\n\t// \t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n\t// \t\t}\n\t// \t}\n\t// }\n\n}\n\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tmodule.exports = (options: Partial<utils.AdapterOptions> | undefined) => new LiquidCheck(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new LiquidCheck())();\n}"],
  "mappings": "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",
  "names": ["axios"]
}
